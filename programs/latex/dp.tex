\documentclass{article} 

\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{cancel}
\usepackage{pgfplots}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\title{Dynamic Programming}
\author{Victor Chui}

\begin{document}
\maketitle
\section{Prerequisite}
\subsection{Bitwise operator}
Computers are operated in binary system. Therefore it is the fastest
to use bitwise operators to handle cases possible as they are 
more efficient.


Most common operators are:
\begin{lstlisting}[language=C++]
int a = 1;
int b = 2;

a << 1; //it shifts one bit to the left, which means a is multiplied by 2.
b >> 1; //it shifts one bit to the right, which means b is divided by 2.

\end{lstlisting}
In general cases, \texttt{<<} multiplies the number or variable by $2^n$.
Similarly, \texttt{>>} divides the number or variable by $2^n$.

Notice that the compiler is smart enough to perform bitwise operation
without user specification. Below is a code snippet:


\begin{lstlisting}[language=C++]
int a = 6;
int b = 16;
int c = a*b;
std::cout << c << std::endl;
\end{lstlisting}
In this problem, b could be represented by $2^n$. The compiler will
take this integer multiplication into bitwise shifting. 
Therefore, we can conclude that $6*16$ is equal to 6 \texttt{<<} 4.
\subsection{Bitwise AND, OR, XOR, Invert}
Let's look at the two below code snippet to better explain bitwise operators.
First:
\begin{lstlisting}[language=C++]
int a = 1;
int b = 1;
cout << a&b << endl;
\end{lstlisting}
In the first code snippet, the terminal will print out 1 or True. 
\\We can conclude that: \[
    AND(m,n) = \begin{cases}
        0, & \text{for a or b equals to 0} \\
        1, & \text{for a and b equals to 1}
        \end{cases}
  \]
Below is the second snippet:
\begin{lstlisting}[language=C++]
int a = 0;
int b = 0;
cout << a|b << endl;
\end{lstlisting}
The terminal will print out 0 or False in this snippet. 
\\We can conclude that: \[
    AND(m,n) = \begin{cases}
        0, & \text{for a and b equals to 0} \\
        1, & \text{for a or b equals to 1}
        \end{cases}
  \]
\section{Knapsack Problem}
\subsection{Introduction}
There are a set of weights $W$ = [2, 3, 4, 5] with cooresponding
profit of $P$ = [1, 2, 5, 6]. The question asks about the maximum 
profit from those weights with the maximum capacity of 8. 


Below is the generic algorithm for solving this 0/1 Knapsack problem.
\subsection{Breakdown}

\begin{equation*}
    V( i,x) = max[ V( i-1, w), V( i-1, w-w[ i])+P[ i]]
\end{equation*}
\subsection{Code Snippet in C++}
\begin{lstlisting}[language=C++]
#include <bits/stdc++.h>
using namespace std;
\end{lstlisting}
\subsection{Conclusion}
To use the Knapsack Algorithm for this 
\subsection{Reference}
Visually explained by Abdul Bari: 


\url{https://www.youtube.com/watch?v=nLmhmB6NzcM&t=944}
\end{document}
